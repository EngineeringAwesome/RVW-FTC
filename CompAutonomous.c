#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  none)
#pragma config(Sensor, S2,     Gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//------------- Constants ---------------------
int kBlue = 45;
int kRed  = 30;
int kGrey = 78;
int kWhite = 89;

long kLowRackPos = 800;
long kMidRackPos = 2000;
long kHighRackPos = 2800;
long armPosition = kLowRackPos;

//------------- Globals -----------------------
//for user feedback
long reading;
long readingHead;
long readingB;

//------------- Function Declarations ---------
void resetDriveEncoders();
void initializeRobot();
void leftSide(int power);
void rightSide(int power);
void stopDriving();
void driveForwardSpeed(int speed);
void driveForwardTime(int speed, int time);
void driveForwardToLine(int speed, int lightVal);
void driveForwardToBox(int speed, int lightVal);
void driveForwardEncoder(int speed, long ticks);
void driveForwardSonar(int speed, int dist);
void driveBackwardSpeed(int speed);
void driveBackwardEncoder(int speed, long ticks);
void driveBackwardToLine(int speed, int lightVal);
void driveBackwardTime(int speed, int time);
void turnLeftSpeed(int speed);
void turnRightSpeed(int speed);
void turnLeftGyro(int speed, int heading);
void turnRightGyro(int speed, int heading);

void closeGripper();
void openGripper();
task gripperUp();
task liftArm();
task lowerArm();
task readSonar();





task main() {
  initializeRobot();
	StartTask(gripperUp);

	armPosition = kLowRackPos;
	StartTask(liftArm);
	//------- Score on right Bonus Peg -------
	turnRightGyro(100, 420);
	driveForwardToLine(100, kWhite);  //drive to the pickup station
	driveForwardEncoder(100, 6*1440);
	driveForwardToLine(75, kWhite);
	turnRightGyro(100, 900);
	driveForwardSonar(100, 3);
	openGripper();
	driveForwardTime(100, 500);   //ram the wall for alignment
	driveBackwardEncoder(100, 1440);

	//------- Return to dispensor -------
	turnLeftGyro(100, 420);
	closeGripper();
	driveBackwardTime(100, 1000);
	driveBackwardToLine(100, kWhite);

	//------- Score in low goal 1 -------
	turnLeftGyro(100, -700);
	driveForwardEncoder(100, 1.25*1440);
	openGripper();

	//------- Return to dispensor -------
	turnRightGyro(100, -420);
	closeGripper();
	driveBackwardToLine(100, kWhite);

	//------- Score in low goal 2 -------
	turnLeftGyro(100, -1500);
	driveForwardEncoder(100, 2.5*1440);
	openGripper();

	//------- Return to dispensor -------
	driveBackwardToLine(100, kWhite);
	closeGripper();

	//------- Score in low goal 3 -------
	turnRightGyro(100, -1200);
	driveForwardEncoder(100, 5*1440);
	openGripper();
	wait1Msec(100);   //allow time for the ring to drop and roll away

	//------- Go to next dispensor -------
	turnRightGyro(100, -520);   //TODO fix this part because it consistantly misses!!!
	closeGripper();
	driveForwardToLine(100, kWhite);

	//------- Score in low goal 4 -------
	turnRightGyro(100, 500);
	driveForwardEncoder(100, 1.25*1440);
	openGripper();

	//------- Return to dispensor
	driveBackwardToLine(100, kWhite);
	closeGripper();

	//------- score on left low peg -------
	turnLeftGyro(100, 200);
	driveForwardEncoder(100, 3*1440);
	driveForwardToLine(100, kWhite);
	turnRightGyro(100, 900);
	openGripper();

	//------- Return to dispensor -------
	turnLeftGyro(100, 200);
	driveBackwardEncoder(100, 1440);
	driveBackwardToLine(100, kWhite);
	closeGripper();

	//------- Score on left mid peg -------
	driveForwardEncoder(100, 3*1440);
	armPosition = kMidRackPos;
	StartTask(liftArm);
	driveForwardToLine(100, kWhite);
	turnRightGyro(100, 900);
	openGripper();

	//------- Return to dispensor -------
	turnLeftGyro(100, 200);
	driveBackwardEncoder(100, 1440);
	driveBackwardToLine(100, kWhite);
	closeGripper();

	//------- Score on left Bonus peg -------
	turnLeftGyro(100, -450);
	driveForwardEncoder(100, 2*1440);
	armPosition = kLowRackPos;
	StartTask(lowerArm);
	driveForwardToLine(100, kWhite);
	turnLeftGyro(100, -950);
	driveForwardSonar(100, 3);
	openGripper();
	driveForwardTime(100, 500);   //ram the wall for alignment

	//------- Drive to next dispensor
	driveBackwardEncoder(100, 1440);
	turnRightGyro(100, 420);
	closeGripper();
	driveForwardToLine(100, kWhite);

	//------- Score on left high peg -------
	armPosition = kHighRackPos;
	StartTask(liftArm);
	turnRightGyro(100, 1400);
	driveForwardEncoder(100, 2*1440);
	driveForwardToLine(100, kWhite);
	turnLeftGyro(100, 900);
	driveForwardEncoder(100, 0.75*1440);
	openGripper();

	//------- Return to dispensor -------
	driveBackwardEncoder(100, 0.75*1440);
	turnRightGyro(100, 1500);
	armPosition = kLowRackPos;
	StartTask(lowerArm);
	driveBackwardEncoder(100, 1440);
	closeGripper();
	driveBackwardToLine(100, kWhite);

	//------- score in low goal 5 -------
	turnLeftGyro(100, 1000);
	driveForwardEncoder(100, 1.5*1440);
	openGripper();

	//------- return to dispensor -------
	turnRightGyro(100, 1600);
	driveBackwardToLine(100, kWhite);
	closeGripper();

	//------- score in low goal 6 -------
	turnLeftGyro(100, 370);
	driveForwardToBox(100, kRed);
	openGripper();

	//------- return to dispensor -------
	driveBackwardToLine(100, kWhite);
	closeGripper();

	//------- score in low goal 7 -------
	turnRightGyro(100, 600);
	driveForwardEncoder(100, 4*1440);
	driveForwardToBox(100, kRed);
	openGripper();
	wait1Msec(200);

	//------- drive to next dispensor -------
	turnRightGyro(100, 1200);
	closeGripper();
	driveForwardToLine(100, kWhite);

	//------- score in low goal 8 -------
	turnRightGyro(100, 2400);
	driveForwardToBox(100, kRed);
	driveForwardEncoder(100, 0.5*1440);
	openGripper();

	//------- return to dispensor -------
	driveBackwardToLine(100, kWhite);
	closeGripper();

	//------- score on right low peg -------
	turnLeftGyro(100, 2000);
	driveForwardEncoder(100, 2*1400);
	driveForwardToLine(100, kWhite);
	turnRightGyro(100, 2700);
	openGripper();

	//------- return to dispensor -------
	turnLeftGyro(100, 2000);
	closeGripper();
	driveBackwardEncoder(100, 2*1440);
	driveBackwardToLine(100, kWhite);

	//------- score on right mid peg -------
	driveForwardEncoder(100, 2*1440);
	armPosition = kMidRackPos;
	StartTask(liftArm);
	driveForwardToLine(100, kWhite);
	turnRightGyro(100, 2700);
	driveForwardEncoder(100, 1440);
	openGripper();

	//------- return to dispensor -------
	driveBackwardEncoder(100, 1440);
	turnLeftGyro(100, 2000);
	driveBackwardEncoder(100, 2*1440);
	closeGripper();
	driveBackwardToLine(100, kWhite);

	//------- score on right high peg -------
	driveForwardEncoder(100, 2*1440);
	armPosition = kHighRackPos;
	StartTask(liftArm);
	driveForwardToLine(100, kWhite);
	turnRightGyro(100, 2700);
	driveForwardEncoder(100, 1440);
	openGripper();



  //------- End! -------
	stopDriving();
	wait1Msec(1000);
}








//------------- Function Definitions -----------
void resetDriveEncoders() {
  nMotorEncoder[motorF] = 0;
	nMotorEncoder[motorG] = 0;
}

void initializeRobot() {
	nMotorEncoder[motorH] = 0;
	nMotorEncoder[motorB] = 0;

	motor[motorA] = 100;			//closes the gripper
	wait1Msec(250);						//and sets position 0
	motor[motorA] = 0;				//to closed
	nMotorEncoder[motorA] = 0;
}

void leftSide(int power) {
  motor[motorE] = power;
  motor[motorG] = power;
}

void rightSide(int power) {
  motor[motorD] = power;
  motor[motorF] = power;
}

void stopDriving() {
	leftSide(0);
	rightSide(0);
}

void driveForwardSpeed(int speed) {
	leftSide(speed);
	rightSide(speed);
}

void driveForwardTime(int speed, int time) {
  driveForwardSpeed(speed);
  wait1Msec(time);
  stopDriving();
}

void driveForwardToLine(int speed, int lightVal) {
	driveForwardSpeed(speed);

	while( SensorValue[lightSensor] < lightVal ) {
		wait1Msec(50);					//continously check sensor
	}													//reading until light value is reached
	stopDriving();
}

void driveForwardToBox(int speed, int lightVal) {
  driveForwardSpeed(speed);

  while( SensorValue[lightSensor]> lightVal ) {
    wait1Msec(50);
  }
  stopDriving();
}

void driveForwardEncoder(int speed, long ticks) {
	resetDriveEncoders();
	driveForwardSpeed(speed);

	while( (nMotorEncoder[motorF] < ticks) || (nMotorEncoder[motorG] > -ticks) ) {
		wait1Msec(10);
	}
	stopDriving();
}

void driveForwardSonar(int speed, int dist) {
	driveForwardSpeed(speed);

	while( SensorValue[sonarSensor] > dist ) {
		reading = SensorValue[sonarSensor];
		wait1Msec(10);
	}
	stopDriving();
}

void driveBackwardSpeed(int speed) {
	motor[motorD] = -speed;
	motor[motorF] = -speed;
	motor[motorE] = -speed;
	motor[motorG] = -speed;
}

void driveBackwardEncoder(int speed, long ticks) {
	resetDriveEncoders();
	driveBackwardSpeed(speed);

	while( (nMotorEncoder[motorF] > -ticks) || (nMotorEncoder[motorG] < ticks) ) {
		reading = nMotorEncoder[motorG];
		wait1Msec(10);
	}
	stopDriving();
}

void driveBackwardToLine(int speed, int lightVal) {
	driveBackwardSpeed(speed);

	while( SensorValue[lightSensor] < lightVal ) {
		wait1Msec(50);					//continously check sensor
	}													//reading until light value is reached
	stopDriving();
}

void driveBackwardTime(int speed, int time) {
  driveBackwardSpeed(speed);
  wait1Msec(time);
  stopDriving();
}

void turnLeftSpeed(int speed) {
  leftSide(-speed);
  rightSide(speed);
}

void turnRightSpeed(int speed) {
  leftSide(speed);
  rightSide(-speed);
}

void turnLeftGyro(int speed, int heading) {
  while (SensorValue[Gyro] > heading) { //turns to the heading at
    turnLeftSpeed(speed);               //high speed to get an approximate heading
  }
  while (SensorValue[Gyro] < heading) { //turn back to the heading
    turnRightSpeed(speed/5);            //at a slower speed for a finer heading
  }
  stopDriving();
  readingHead = SensorValue[Gyro];
}

void turnRightGyro(int speed, int heading) {
  while (SensorValue[Gyro] < heading) {
    turnRightSpeed(speed);
  }
  while (SensorValue[Gyro] > heading) {
    turnLeftSpeed(speed/5);
  }
  stopDriving();
  readingHead = SensorValue[Gyro];
}

void turnGyro(int speed, int heading) {
	int largeThreshold = 45;		//stair stepped threshold values
	int threshold = 0.5;				//large threshold for a general heading range, and then a threshold for fine tuning

	while( abs(heading-SensorValue[Gyro]) > threshold ) {	//loop until within smaller threshold
		if( abs(heading-SensorValue[Gyro]) > largeThreshold ) { //Drive fast in the large threshold
			if ( (heading-SensorValue[Gyro]) > 0 ) {
				turnRightSpeed(speed);
			}
			else {
				turnLeftSpeed(speed);
			}
		}
		else {
			if ( (heading-SensorValue[Gyro]) > 0 ) {	//drive at 1/2 speed when within larger threshold
			turnRightSpeed(speed/7);												//for fine tuning of heading
			}
			else {
				turnLeftSpeed(speed/7);
			}
		}
		reading = SensorValue[Gyro];
	}
	stopDriving();
}

void closeGripper() {
	while( nMotorEncoder[motorA] < -20 ) {	//closes the 		TODO: add timeout
		motor[motorA] = 100;									//gripper to a
	}																				//set position
	motor[motorA] = 0;
}

void openGripper() {
	while( nMotorEncoder[motorA] > -40 ) {	//opens the 		TODO: add timeout
		motor[motorA] = -100;									//gripper to a
	}																				//set position
	motor[motorA] = 0;
}
task gripperUp() {
  nMotorEncoder(motorB) = 0;

  motor[motorB] = 100;  //move motor outside of sticking point
  wait1Msec(100);
  motor[motorB] = 0;

  motor[motorB] = 60;   //move motor to specified up position
  while (nMotorEncoder[motorB] < 150) {
    readingB = nMotorEncoder[motorB];
  }
  motor[motorB] = 0;

  wait1Msec(1000);
  motor[motorB] = -20;
  while (nMotorEncoder[motorB] > 150) {
  }
  motor[motorB] = 0;
  readingB = nMotorEncoder[motorB];
  StopTask(gripperUp);
}

task liftArm() {
  motor[motorH] = 50;
	while (nMotorEncoder[motorH] < armPosition) {
	  reading = nMotorEncoder[motorH];
	}
	motor[motorH] = 0;
	StopTask(liftArm);
}

task lowerArm() {
  motor[motorH] = -50;
  while (nMotorEncoder[motorH] > armPosition) {
  }
  motor[motorH] = 0;
  StopTask(lowerArm);
}

task readSonar() {
	while(true) {
		reading = SensorValue[sonarSensor];
		wait1Msec(50);
	}
}
